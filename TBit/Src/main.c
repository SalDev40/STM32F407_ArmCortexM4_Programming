/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 *
 * NOTES:
 *
 - LSB of PC bit[0] is loaded into the T-bit, therefore it must always be 1,
 if it is 0 processor thinks next instruction is ARM ISA, since CortexMx
 processor does not support ARM ISA, T-Bit must be 1, to execute THUMB ISA.
 usually compiler takes care of this for high level instructions, be
 careful  when we are placing RAW values into the PC, must be odd.
 *
 *  - Reason why we see all vector addresses are incremented by 1 in the
 *  vector table
 *
 */

#include<stdio.h>
#include<stdint.h>

void tBit(void) {
	printf("TBit\n");
}

int main(void) {

	void (*funPtr)(void);

	//before storing address of tBit()
	//compiler increments it by 1,
	//if you see .list file address will
	//be even but variable will be odd
	//0x80001e8 = true address in memory
	//0x80001e9 = address in variable

	funPtr = (void*) (tBit);

	//address of tBit()+1= 0x80001e9
	//is loaded into PC, bit[0] = 1,
	//will be copied into T-Bit
	funPtr();



	/**
	 * Will Fault because we are loading an even number into PC
	 * bit[0] = 0, T-Bit will be 0, therefore processor will
	 * think its loading an ARM ISA which it can't handle
	 *
	 */


	funPtr = (void*) 0x80001e8;
	funPtr();
	while (1)
		;
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void RTC_WKUP_IRQHandler(void) {
	printf("In handler mode : ISR\n");
}

/* Fault handler */
void HardFault_Handler(void) {

	printf("Hard fault detected\n");
	while (1)
		;

}

