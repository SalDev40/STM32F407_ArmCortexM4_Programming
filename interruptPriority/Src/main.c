/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * Notes:
 *
 *	- Lower priority value, stronger the interrupt
 *
 *	- STM32F4xxxx has 16 diff interrupt values
 *
 *	- 60 registers, NVIC_IPR0-NVIC_IP59
 *		- 4 interrupts per register (60*4 = 240 interrupts)
 *
 *	- 32 bits register/4 interrupts = 8 bits per interrupt
 *	- Not all 8 bits are implemented
 *		- 3 btis implemented = 8 priority values (2^3)
 *		- 4 btis implemented = 16 priority values (2^4)
 *			- STM32F4XXX = 4 bits implemented
 *
 *	- Example:
 *		- IRQ0 = NIVC_IPR0 (bit[0]-bit[7]
 *		- IRQ1 = NIVC_IPR0 (bit[8]-bit[15]
 *
 *
 *	- SysBlock Periperhal (Config Exceptions):
 *		- System handler priority registers
 *			- implement priority of exceptions
 *
 *	- What happens if two same priority values hit processor?
 *		- sub priority will be checked: lower wins
 *
 *	- ** Priority Grouping ** :
 *
 *		- Controlled by changing value in:
 *			- SCB peripheral:
 *				- Application Interrupt and Reset Control Register
 *
 *
 *		- Pre-Empt priority:
 *			- when processor running an interrupt handler, and another
 *				interrupt appears, pre-empt priority values will be compared.
 *				Lower value wins
 *
 *		- Sub Priority:
 *			- when two interrupts with same pre-empt priority values,
 *				then sub-priority value checked. Lower value wins
 *
 *		- Groups: (8 total, 0-7)
 *
 *			- default is group 0:
 *				- bit[0] = sub-priority
 *				- bit[1:7] = pre-empt priority
 *
 *		 	- group 1:
 *				- bit[0:1] = sub-priority
 *				- bit[2:7] = pre-empt priority
 *
 *			 - group 3:
 *				- bit[0:2] = sub-priority
 *				- bit[3:7] = pre-empt priority
 *
 *
 *		- Priority Group  = 0
 *
 *				- bit[0:4] = not implemented
 *
 *				- bit[0] = sub-priority
 *					- bit[0] = not implemented
 *						- so no subpriority
 *
 *				- bit[1:7] = pre-empt priority:
 *					- only 3 bits are used to implemented bit[5:7]
 *						- 8 programmabled priority lvls
 *
 *
 *		- Priority Group  = 5
 * 				- bit[0:4] = not implemented
 *
 *				- bit[5] = sub-priority
 *					- 1 programmable values = 2 bits
 *
 *				- bit[6:7] = pre-empt priority:
 *					- 4 programmable values = 2 bits
 *
 *
 *	- What happens if two same pre-empt priority and sub-priority values hit processor?
 *
 *			- Interrupt with Lowest IRQ value is let in
 */

#define IRQNO_TIMER2 28
#define IRQNO_I2C1 31
#define NVIC_ISER_BASE 0xE000E100 //enable register
#define NVIC_ISPR_BASE 0xE000E200 //pending register
#define NVIC_IPR_BASE 0xE000E400 //priority register

#include <stdio.h>
#include <stdint.h>

uint32_t volatile *const NVIC_ISPR0 = (uint32_t*) (NVIC_ISPR_BASE);
uint32_t volatile *const NVIC_ISER0 = (uint32_t*) (NVIC_ISER_BASE);

/**
 * 	- IPR0 -> IPR59 (60 total register)
 * 		- 1. Find correct register?
 * 			floor(IRQ_NO / 4 (# of IRQ per register)) * 4 (one word)
 *
 * 		- 2. Find correct bit positions?
 * 			(IRQ_NO % 4) x 8
 *
 * 		- Example:
 * 			1. floor(38/4) = 9
 * 			2. (38 % 4) x 8 = 2 x 8 = 16
 * 				- 16bit - 24th bit
 *
 * 			Location = Register 9 bits[16:24]
 */

/**
 * 	@param irqNo = IRQ_NO of peripheral
 * 	@param priorityValue  = priority value to set for given IRQ_NO
 * 		- STM32F4xxx = allows max 16 priority levels (0x00 -> 0xf0)
 *
 */

void configure_priority_for_irq(uint8_t irqNo, uint8_t priorityValue) {
	/**
	 * 1. find IPR register
	 */
	uint32_t iprx = (irqNo / 4) * 4; // * 4 ( 32 bits per register)
	uint32_t volatile *const NVIC_IPRx = (uint32_t*) (NVIC_IPR_BASE + iprx);

	/*
	 * 2. find bit position in register
	 */

	uint8_t posIprx = (irqNo % 4) * 8;

	/*
	 * 3. configure priority
	 */

	*NVIC_IPRx &= ~(0xFF << posIprx); //clear
	*NVIC_IPRx |= (priorityValue << posIprx);
}

int main(void) {

	/*
	 *	- base + offset (peripheral IRQ_NO in register 0-7 ?)
	 *		- TIM2 (IRQ_NO = 38)
	 * 			- (0xE000E200 + 4)
	 * 			- +4 = one word
	 * 			- 38 falls in register  NVIC_ISPR1
	 *
	 * 		- I2C1 (IRQ_NO = 31)
	 * 			- (0xE000E200 + 0)
	 * 			- 31 falls in register  NVIC_ISPR0
	 *
	 */

	/**
	 * 1. Configure priority for peripheral
	 */

	/* same priority levels */
	configure_priority_for_irq(IRQNO_I2C1, 0x80);
	configure_priority_for_irq(IRQNO_TIMER2, 0x80);

	/* different priority levels (lower wins)*/
//	configure_priority_for_irq(IRQNO_I2C1, 0x20);

	/**
	 * 2. Set interrupt pending bit in NVIC_ISPR:
	 * 		- Formula to find correct bit:
	 * 	 		IRQ_NO % (Register Size in bits)
	 * 	 	- will be cleared for IRQNO when its handled
	 *
	 */

//	*NVIC_ISPR0 |= (1 << (IRQNO_I2C1 % 32)); //wont be handled until pending bit is set
	*NVIC_ISPR0 |= (1 << (IRQNO_TIMER2 % 32));

	/**
	 * 3. Enable active bit in NVIC_ISER
	 * 		- Formula to find correct bit:
	 * 	 		IRQ_NO % (Register Size in bits)
	 */

	*NVIC_ISER0 |= (1 << (IRQNO_I2C1 % 32));
	*NVIC_ISER0 |= (1 << (IRQNO_TIMER2 % 32));

}

/**
 * 4. Implement ISR
 */

void TIM2_IRQHandler(void) {
	printf("In [TIM2_IRQHandler handler\n");

	/*
	 *  wont leave this handler unless I2C1 has higher priority
	 * will be pending until its handled, then cleared from ISPR
	 *
	 */
	*NVIC_ISPR0 |= (1 << (IRQNO_I2C1 % 32));
	while (1)
		;
}

void I2C1_EV_IRQHandler(void) {
	printf("In [I2C1_EV_IRQHandler] handler\n");
}

