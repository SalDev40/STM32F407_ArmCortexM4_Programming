/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/** NOTES:
 *
 * - Default is MSP (used after reset, handler mode codes) as SP
 *
 * - PSP (can only be used in thread mode), used for application tasks
 *
 * - Can change  SP to PSP from Thread Mode
 * 		- use CONTROL register
 * 		- Have choice between PSP and MSP
 *
 * - Handler Mode always uses MSP as SP
 * 		- changing to PSP wont do anything, ALWAYS MSP
 *
 * - Stack grows down from end (top) of RAM in Arm CortexMx
 * - Linker Script initializes stack region using
 * 		_estack symbol = located at end (top) of RAM
 *
 * - First Entry of Vector Table Entry is initial stack address
 * 		- when processor undergoes reset, first job is to fetch
 * 		 the first entry of vector table and initialize MSP register
 *
 *	----- ** SPLIT STACK FOR THREAD / HANDLER MODE ** ------
 * - Before using PSP, we have to initialize it:
 *
 * 		- 1kb stack size ->  divide into 2 parts, MSP = 512b, PSP = 512b
 *
 *
 * 		- STACK_MSP_START -> STACK_MSP_END,  STACK_PSP_START -> STACK_PSP_END
 * 		- (			HANDLE MODE STACK     ), (		THREAD MODE STACK       )
 *
 * 		- RTOS or embedded OS, usually kernel mode gets own stack
 * 			and user mode its own
 * 			- Kernel Mode (handler mode) is MSP
 * 			= User Mode (thread mode) is PSP
 *
 */

#define SRAM_START 0x20000000U
#define SRAM_SIZE	(128 * 1024)
#define SRAM_END  ((SRAM_START) + (SRAM_SIZE))
#define STACK_START  SRAM_END

#define STACK_MSP_START  STACK_START
#define STACK_MSP_END (STACK_MSP_START  - 512)

#define STACK_PSP_START  STACK_MSP_END
//#define STACK_PSP_END (STACK_PSP_START  - 512)

#include <stdio.h>

/*
 * change control register bit[1] to 1
 * sets PSP as current stack pointer
 */
__attribute__((naked)) void changeSpToPsp(void) {

	/* create assembler directives, like assembler "macros" */
	__asm volatile(".equ SRAM_END, (0x20000000 + (128 * 1024))");
	__asm volatile(".equ PSP_START, (SRAM_END-512)");

	/* load PSP_START address into PSP register*/
	__asm volatile("LDR R0, =PSP_START");
	__asm volatile("MSR PSP, R0");

	/* set CONTROL register first bit to 1, will make SP -> PSP */
	__asm volatile("MOV R0, #0x02");
	__asm volatile("MSR CONTROL, R0");

	/* return to main function, branch to address at LR register */
	/* will copy address in LR register  to PC register */
	__asm volatile("BX LR");

}

/*
 * Cause exception, will change to Handler Mode
 * Handler Mode will use MSP as SP always
 */
void generateException(void) {
	__asm volatile("SVC #0x02");
}

/* Executes in THREAD MODE, default is MSP as SP*/
int main(void) {

	/* will change SP to PSP from MSP, THREAD mode  */
	changeSpToPsp();

	/* will change SP to MSP, HANDLER  mode  */
	generateException();

	/* SP will be PSP again in THREAD MODE*/

	/* Loop forever */
	for (;;)
		;
}

void SVC_HANDLER(void) {
	printf("In SVC HANDLER");
	/* will return and SP will be PSP again */
}

