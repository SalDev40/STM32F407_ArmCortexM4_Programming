/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdio.h>
#include "main.h"
#include "led.h"

int main(void) {

	enable_processor_faults();

	init_scheduler_stack(SCHED_STACK_START);

	init_task_stack();

	led_init_all();

	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();

	for (;;)
		;
}

/* Pre initializtion */
void enable_processor_faults() {
	uint32_t volatile *const pSHCRS = (uint32_t*) 0xE000ED24;

	*pSHCRS |= (1 << 16); //MemFault
	*pSHCRS |= (1 << 17); //BusFault
	*pSHCRS |= (1 << 18); //UsageFault
}

__attribute__((naked)) void init_scheduler_stack(uint32_t schedTopOfStack) {

	__asm volatile("MSR MSP, %0" : : "r"(schedTopOfStack));
	__asm volatile("BX LR");
}

void init_task_stack(void) {

	tcb[0].currentState = TASK_READY_STATE;
	tcb[1].currentState = TASK_READY_STATE;
	tcb[2].currentState = TASK_READY_STATE;
	tcb[3].currentState = TASK_READY_STATE;
	tcb[4].currentState = TASK_READY_STATE;

	tcb[0].pspValue = IDLE_STACK_START;
	tcb[1].pspValue = T1_STACK_START;
	tcb[2].pspValue = T2_STACK_START;
	tcb[3].pspValue = T3_STACK_START;
	tcb[4].pspValue = T4_STACK_START;

	tcb[0].taskHandler = taskIdle_handler;
	tcb[1].taskHandler = task1_handler;
	tcb[2].taskHandler = task2_handler;
	tcb[3].taskHandler = task3_handler;
	tcb[4].taskHandler = task4_handler;

	uint32_t *pPSP;
	for (int i = 0; i < MAX_TASKS; i++) {
		pPSP = (uint32_t*) tcb[i].pspValue;

		/*	- Full descending stack
		 *	- For each task:
		 * 		Initilaze stack frames SF1 and SF2 with dummy variables
		 */

		pPSP--; //XPSR
		*pPSP = 0x01000000;

		pPSP--; //PC
		*pPSP = (uint32_t) tcb[i].taskHandler; //T-Bit

		pPSP--; //LR
		*pPSP = 0xFFFFFFFD;

		//General Purpose Registers
		for (int i = 0; i < 13; i++) {
			pPSP--;
			*pPSP = 0;
		}

		/* update PSP value to new address of stacking for task */
		tcb[i].pspValue = (uint32_t) pPSP;

	}
}

void init_systick_timer(uint32_t tickHz) {

	/* SysTick Reload Value register */
	uint32_t volatile *const pSYST_RVR = (uint32_t*) 0xE000E014;
	uint32_t volatile *const pSYST_CSR = (uint32_t*) 0xE000E010;
	uint32_t countValue = SYSTICK_TIM_CLK / tickHz - 1;

	/* Clear SVR */
	*pSYST_RVR &= ~(0x00FFFFFFFF);

	/* load value in SVR */
	*pSYST_RVR |= countValue;

	/* do some settings */
	*pSYST_CSR |= (1 << 1); //enables SysTick exception request
	*pSYST_CSR |= (1 << 2); //indicates clock source = processor clock source

	/* enable systick */
	*pSYST_CSR |= (1 << 0); //enables the couter

}

__attribute__((naked)) void switch_sp_to_psp(void) {

	/* save LR to return to main
	 * BL next instr will corrupt  it
	 */
	__asm volatile("PUSH {LR}");

	/* get PSP value of current task */
	__asm volatile("BL get_psp_value");

	/* Initialize PSP: returned from get_psp_value() in R0 */
	__asm volatile("MSR PSP, R0");

	/* pops (restores) back LR */
	__asm volatile("POP {LR}");

	/* set CONTROL register first bit to 1, will make SP -> PSP */
	__asm volatile("MOV R0, #0x02");
	__asm volatile("MSR CONTROL, R0");

	/* return to main */
	__asm volatile("BX LR");
}

uint32_t get_psp_value(void) {
	return tcb[currentTask].pspValue;
}

void set_psp_value(uint32_t currentPspValue) {
	tcb[currentTask].pspValue = currentPspValue;
}

void update_next_task(void) {
	int state = TASK_BLOCKED_STATE;
	for (int i = 0; i < (MAX_TASKS); i++) {
		currentTask++;
		currentTask %= MAX_TASKS;
		state = tcb[currentTask].currentState;
		if ((state == TASK_READY_STATE) && (currentTask != 0))
			break;
	}

	if (state != TASK_READY_STATE)
		currentTask = 0;
}

void unblock_tasks(void) {
	/* unblock all tasks which are ready */
	for (int i = 1; i < MAX_TASKS; i++) {
		if (tcb[i].currentState != TASK_READY_STATE) {
			if (tcb[i].blockCount == gTickCount) {
				tcb[i].currentState = TASK_READY_STATE;
			}
		}
	}
}

void schedule_pend_sv(void) {
	//pend the pendsv exception
	uint32_t volatile *const pICSR = (uint32_t*) 0xE000ED04;
	*pICSR |= (1 << 28);
}

void task_delay(uint32_t tickCount) {
	if (currentTask > 0) {
		tcb[currentTask].blockCount = gTickCount + tickCount;
		tcb[currentTask].currentState = TASK_BLOCKED_STATE;
		schedule_pend_sv();
	}
}

void SysTick_Handler(void) {
	gTickCount++;
	unblock_tasks();
	schedule_pend_sv();

}

__attribute__((naked)) void PendSV_Handler(void) {

	/* A) Save context of current task */

	/* 1. Save LR and get current running tasks PSP */
	__asm volatile("PUSH {LR}");
	__asm volatile("MRS R0, PSP");

	/* 2. using PSP store SF2 (R4-R11)
	 * 		- cant use PUSH -> will corrupt MSP
	 */
	__asm volatile("STMDB R0!, {R4-R11}");

	/* 3. save current new value of PSP for task */
	__asm volatile("BL set_psp_value");

	/* B) Retrieve context of next task */

	/* 1. Decide next task to run */
	__asm volatile("BL update_next_task");

	/* 2. get its PSP value */
	__asm volatile("BL get_psp_value");

	/* 3. using that PSP value retrieve SF2 (R4-R11)*/
	__asm volatile("LDMIA R0!, {R4-R11}");

	/* 4. update PSP and return */
	__asm volatile("MSR PSP, R0");
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");

}

/* Task Handler */
void task1_handler(void) {
	while (1) {
		led_on(LED_GREEN);
		task_delay(100);
		led_off(LED_GREEN);
	}
}

void task2_handler(void) {
	while (1) {
		led_on(LED_ORANGE);
		task_delay(250);
		led_off(LED_ORANGE);
	}
}

void task3_handler(void) {
	while (1) {
		led_on(LED_BLUE);
		task_delay(500);
		led_off(LED_BLUE);
	}
}

void task4_handler(void) {
	while (1) {
		led_on(LED_RED);
		task_delay(1000);
		led_off(LED_RED);
	}
}

void taskIdle_handler(void) {
	while (1) {
		printf("\n[taskIdle_handler] \n");
	}
}

void MemManage_Handler(void) {
	printf("[MemManage_Handler]");
	while (1)
		;
}
void BusFault_Handler(void) {
	printf("[BusFault_Handler]");
	while (1)
		;
}

void UsageFault_Handler(void) {
	printf("[UsageFault_Handler]");
	while (1)
		;
}

void HardFault_Handler(void) {
	printf("[HardFault_Handler]");
	while (1)
		;
}

