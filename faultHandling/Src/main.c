/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 * Notes:
 *
 * 		- Fault happens b/c of programmers handling processor
 * 			violates design rules or interfaces processor deals with
 * 			EX:
 * 				- Division by 0
 * 				- Undefined instruction
 * 				- Memory access to guarded region
 * 				- Attempt to execute code from XN (execute never) region
 *
 * 		- Fault occurs:
 * 			- internal processor registers will be updated to record type of fault
 * 			- address of instruction where fault happened
 * 			- if handler is associated, it will be called
 *					- programmer code is used to deal with fault
 *
 *		- ARM Cortex Mx:
 *			- has 15 system exeptions ( 1- 15 )
 *				- 9 system exceptions implemented (rest reserved)
 *
 *			- Lower priority value = Higher importance
 *
 *			- Reset, NMI, HardFault
 *				- system exceptions
 *				- non configurable
 *
 *			- MemManage, BusFault, UsageFault, HardFault
 *				- Fault exceptions
 *				- will rise whenever their is fault in processor
 *
 *			- HardFault - enabled by default (non-configurable priority)
 *					- can be disabled by using FAULTMASK register
 *					- occurs because of an error during exception processing
 *						or because an exception cannot be managed
 *						by any other exception mechanism
 *
 *					- 3rd highest fixed priority (-1)
 *
 *					- Causes:
 *						1. (COMMON) Escalation of configurable exceptions
 *								(MemManage, BusFault, UsageFault)
 *
 *						2. Bus Error returned during vector fetch
 *						3. Execution of break point instruction when both
 *							halt and debug mode are disabled
 *						4. Executing SVC instruction in SVC handler
 *
 *					- HardFault Status Register:
 *						- bit[1] = bus fault on vector table read
 *						- bit[30] = FORCED, escalation of fault with config priority
 *						- bit[31] = DEBUGEVT
 *						- rest bits reserved
 *
 *				- UsageFault - disabled by default (configurable priority)
 *				- MemManage - disabled by default (configurable priority)
 *				- BusFault - disabled by default (configurable priority)
 *
 *					- If configurable exception is enabled
 *						handled by configurable exception handlers
 *
 *					- If configurable exception is not enabled
 *						handled by hardfault handler
 *
 *					- Location = System Control Block:
 *						- System Handler Control and State Register (SHCSR)
 *
 *
 *			- When a fault happens you can check a couple of
 *				fault status and fault address registers to get more
 *				details about fault and instruction address it occured at.
 *
 *			- HFSR
 *			- MMFSR, MMFAR
 *			- BFSR, BFAR
 *			- UFSR
 *
 *
 */

#include <stdint.h>
#include <stdio.h>

int main(void) {

	/**
	 * 1. Enable all configurable fault exceptions
	 * 		- MemManage, BusFault, UsageFault,
	 */

	uint32_t volatile *const pSHCRS = (uint32_t*) 0xE000ED24;

	*pSHCRS |= (1 << 16); //MemFault
	*pSHCRS |= (1 << 17); //BusFault
	*pSHCRS |= (1 << 18); //UsageFault

	/**
	 * 3. Force processor to execute undefined instruction
	 */

	uint32_t volatile *const pSRAM = (uint32_t*) 0x20010000;
	*pSRAM = 0xFFFFFFFF; //stored invalid instruction

	void (*some_address)(void);
//	some_address = (void*) 0x20010000; // Illegal: T-Bit = 0
	some_address = (void*) 0x20010001; //T-Bit must be 1

	some_address();

	/**
	 * 4. Divide by Zero trap
	 */
	uint32_t volatile *const pCCR = (uint32_t*) 0xE000ED14;
	*pCCR |= (1 << 4);

	uint32_t x = 10/0;

	/* Loop forever */
	for (;;)
		;
}

/**
 * 2. Implement Fault Handlers
 */
void MemManage_Handler(void) {
	printf("[MemManage_Handler]");
	while (1)
		;
}
void BusFault_Handler(void) {
	printf("[BusFault_Handler]");
	while (1)
		;
}

/* Assembly function to prevent C epilogue and prologue*/
__attribute ((naked)) void UsageFault_Handler(void) {
	/*
	 * - Function Epilogue in C = Changes value of stack pointer
	 * 	therefore we must write a pure assembly function
	 *
	 * 	stack anaylzing, must be before
	 * 	any Handler code so we can analyze registers
	 * 	properly, before any changes
	 */

	/*
	 * 	- Extract the value of MSP which happens
	 * 	to be the base address of the stack frame
	 * 	which got saved during the exception from thread mode
	 * 	to handler mode
	 *
	 *  - Store the value of MSP in r0
	 * 	value of r0 will be argument 1 in caller function
	 * 	according to standard
	 *
	 */

	__asm volatile("MRS r0, MSP");

	/* Jump to C function*/
	__asm volatile("B UsageFault_Handler_C");

}
/**
 * pBaseStackFrame = r0 value from callee
 */
void UsageFault_Handler_C(uint32_t *pBaseStackFrame) {

	//only 16 bits are used rest are reserved
	uint32_t volatile *const pUFSR = (uint32_t*) 0xE000ED2A;

	printf("[UsageFault_Handler]");
	printf("USFR: %lx\n", (*pUFSR) & 0xFFFF); //read 16 bits

	/** print details of last stack frame **/
	printf("MSP = pBaseStackFrame", pBaseStackFrame);
	printf("R0: %lx\n", pBaseStackFrame[0]);
	printf("R1: %lx\n", pBaseStackFrame[1]);
	printf("R2: %lx\n", pBaseStackFrame[2]);
	printf("R3: %lx\n", pBaseStackFrame[3]);
	printf("R12: %lx\n", pBaseStackFrame[4]);
	printf("LR: %lx\n", pBaseStackFrame[5]);
	printf("PC: %lx\n", pBaseStackFrame[6]);
	printf("XPSR: %lx\n", pBaseStackFrame[7]);

	while (1)
		;

}

void HardFault_Handler(void) {
	printf("[HardFault_Handler]");
	while (1)
		;
}

